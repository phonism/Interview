# LuckyQueen 做题笔记

+ [CF1463E: Plan of Lectures](https://codeforces.com/contest/1463/problem/E)
    + **题意：**要求构造一个1~n的排列，满足：1. p[i]出现在i之前。2. k个特殊pair(x,y)，在最终的排列中是紧挨着的。
	+ **题解：**对于特殊pair，先进行缩点，缩点要记录每个点内的序，用于判断点内是否有环或者和原有的序有冲突。然后进行拓扑排序，如果不是拓扑序，代表不OK，如果是拓扑序就输出拓扑序即可。
	+ **标签：**拓扑序，P1，L5
+ [ARC099E: Independence](https://atcoder.jp/contests/arc099/tasks/arc099_c)
    + **题意：**n(<700)个点，m条边，n个点划分为两个完全子图并且子图的边数最少的个数是多少。
    + **题解：**正着求比较难求，考虑建反图，那么某些点是完全子图的条件是这些点都是孤立的点，可以发现是要做二分图划分，那么这题就转变成判断反图里的每个连通块是否是二分图。判断完之后，如果找最小值呢，可以将每个二分图0 1的个数当做物品，做分组背包，得到哪些组合是ok的，最终求出这些可行方案里的最小值。
    + **标签：**二分图，分组背包，dp，P0，L6
+ [CF1270E: Divide Points](https://codeforces.com/contest/1270/problem/E)
	+ **题意：**给出n个点，把n个点分成两个部分，在同一个部分的两点距离值的集合为A，不同部分的两点距离集合为B，为如何划分，使得A和B无交集。
	+ **题解：**考虑坐标的奇偶性，一共有a00,a11,a01,a10四种情况，然后分情况去讨论即可，如果当前都是A00这种，可以考虑对坐标/2，或者+1这种来改变奇偶性最终根据结果奇偶来划分两个区间即可。
	+ **标签：**ad-hoc，奇偶性，P1，L6
+ [CF1110F: Nearest Leaf](https://codeforces.com/contest/1110/problem/F)
	+ **题意：**给出以1为根节点的有根树，边有边权，再给定m次查询，每次查询v,l,r，表示以v为起点，终点为l-r以内的叶子节点最短的距离是多少，有一个特殊条件是树的dfs序恰好是1-n
	+ **题解：**dfs序是1-n的条件说明了一个节点的子树正好是一个连续的序列。然后我们可以考虑dfs整棵树，当dfs到节点u到dfs节点v的时候，假设边权为w，那么当前if 叶子节点在子树v: 节点v到每个叶子节点的距离 = 节点u到叶子节点距离 - w else 节点v到每个叶子节点的距离 = 节点u到叶子节点距离 + w。这么就简单了，先dfs一边得到每个节点在dfs序上的st和ed，然后离线处理查询，用线段树维护，对非叶子节点设为inf，然后维护每个节点到根节点的距离（这个可以通过更新每个节点的root方向边权到子树区间即可），最后再dfs一遍，一边dfs一边对当前v的子树 - w，对于其他区间+ w。
	+ **标签：**dfs序，线段树，P0，L7
+ [CF888G: Xor-MST](https://codeforces.com/contest/888/problem/G)
	+ **题意：**给出n个点的完全图，边权等于两个端点点权的异或值，问最小生成树是多少。
	+ **题解：**很容易想到对于最高位为k的数，优先需要连最高位一样的边，因为连其他的边肯定都不对。但是最高位不一样的数总要互相连，这次连似乎只能暴力求解，优先连最高位的边似乎也要暴力。这里可以在trie树上去做，在trie树上dfs，对于有两个儿子的节点，暴力对这两个子树连边。可以发现有两个儿子的节点最多只有n-1个，
	+ **标签：**trie，贪心，P0，L7
+ [CF449C: Jzzhu and Apples](https://codeforces.com/contest/449/problem/C)
	+ **题意：**给1-n，问这n个数能分成多少pair，pair的两个数gcd>1。输出分法
	+ **题解：**显然和质因子有关，质因子越大，数越少，对于某个数，我们应该优先用在质因子比较大的gcd pair里。那么可以从大的质因子到小的质因子去遍历，优先用大的，那么如果某一个质因子p有奇数个怎么办，可以发现p*2一定之前没被用过，因为是从大到小遍历，而且每一个p*2都一定有公约数，这样一定是最优的！
	+ **标签：**贪心，ad-hoc，P1，L6
